#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2006 David Belohrad
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA  02110-1301, USA.
#
# You can dowload a copy of the GNU General Public License here:
# http://www.gnu.org/licenses/gpl.txt
#
# Author: David Belohrad
# Email:  david.belohrad@cern.ch
#

"""
This application takes as the input the CSV bill-of-material file
generated by KiCad PCBNEW tool. It displays all the components in the
table. By clicking on read-only table items (value, manufacturer,
footprint) a default browser is launched, which searches for a
clicked keyword on the pages of farnell. This can be used to fast
search the farnell ordering codes. The application supports drag-drop
functionality, hence if user selects the farnell ordering code, it can
be dragged to the application to a specific column. This is a
hack-style tool, which allows the PCB designer to quickly search for
manufacturer part independently of the values of the libraries.
"""

import sys
import os
import webbrowser
from collections import defaultdict
from PyQt4 import QtGui, uic, QtCore
from .sch_parser import sch_parser
from .headers import headers
from .qdesignatorsortmodel import QDesignatorSortModel

localpath = os.path.dirname(os.path.realpath(__file__))
form_class = uic.loadUiType(os.path.join(localpath, "BOMLinker.ui"))[0]


class BOMizator(QtGui.QMainWindow, form_class):
    def __init__(self, projectDirectory, parent=None, flags=0):
        """ Constructing small window with tree view of all components
    present in the schematics. Directory points to the KiCad project
    directory containing .sch (they can be in sub-directories as well)
        """
        QtGui.QMainWindow.__init__(self, parent, QtCore.Qt.WindowFlags(flags))
        self.setupUi(self)

        self.BOM = []
        self.settings = QtCore.QSettings()

        self.projectDirectory = projectDirectory
        self.SCH = sch_parser(self.projectDirectory)
        self.SCH.parse_components()

        self.model = QtGui.QStandardItemModel(self.treeView)
        # search proxy:
        self.proxy = QDesignatorSortModel(self.treeView)
        self.proxy.setSourceModel(self.model)
        self.proxy.setDynamicSortFilter(True)
        # assign proxy to treeView so we influence how the stuff is sorted
        self.treeView.setModel(self.proxy)
        self.treeView.setSortingEnabled(True)
        # get header object
        self.header = headers()

        sorted_header = self.header.get_headers()
        self.model.setHorizontalHeaderLabels(sorted_header)
        # set sorting of treeview by designator
        self.treeView.sortByColumn(self.header.get_column(
            self.header.DESIGNATOR), QtCore.Qt.AscendingOrder)

        # having headers we might deploy the data into the multicolumn
        # view. We need to collect all the data:
        for itemData in self.SCH.BOM():
            line = map(QtGui.QStandardItem, list(itemData))
            columns = self.header.get_columns([self.header.DESIGNATOR,
                                              self.header.LIBREF,
                                              self.header.VALUE,
                                              self.header.FOOTPRINT])
            editable = filter(lambda item: item in columns, line)
            map(lambda ei: ei.setEditable(False), editable)

            self.model.appendRow(list(line))

        # as the model is filled with the data, we can resize columns
        # for i in range(len(self.header)):
        #     self.treeView.resizeColumnToContents(i)

        # connect signals to treeView so we can invoke search engines
        self.treeView.doubleClicked.connect(self.tree_doubleclick)
        # register accepting drops
        self.treeView.setAcceptDrops(True)
        self.treeView.setDropIndicatorShown(True)
        # and register custom context menu, which will be used as
        # 'filtering' to select correcly chosen indices
        self.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeView.customContextMenuRequested.connect(self.openMenu)

        # restore windows parameters
        self._readAndApplyWindowAttributeSettings()

    def indexData(self, index):
        """ convenience function returning the data of given
        modelindex. Gets complicated because we are using filter
        proxy, hence the index has to be converted to source model index.
        """
        return self.proxy.itemData(index)[QtCore.Qt.DisplayRole]

    def resizeEvent(self, event):
        """ reimplementation of resize event to store state into settings
        """
        super(BOMizator, self).resizeEvent(event)
        self._writeWindowAttributeSettings()

    def moveEvent(self, event):
        """ reimplementation of move event to store state into settings
        """
        super(BOMizator, self).moveEvent(event)
        self._writeWindowAttributeSettings()

    def closeEvent(self, event):
        """ reimplemented close to save window position
        """
        super(BOMizator, self).closeEvent(event)
        self._writeWindowAttributeSettings()

    def _readAndApplyWindowAttributeSettings(self):
        """ Read window attributes from settings, using current
        attributes as defaults (if settings not exist.) Called at
        QMainWindow initialization, before show().  """

        self.settings.beginGroup("mainWindow")
        self.restoreGeometry(self.settings.value("geometry",
                                                 self.saveGeometry()))
        self.restoreState(self.settings.value("saveState", self.saveState()))
        self.move(self.settings.value("pos", self.pos()))
        self.resize(self.settings.value("size", self.size()))
        if self.settings.value("maximized", self.isMaximized()):
            self.showMaximized()

        self.settings.endGroup()

    def _writeWindowAttributeSettings(self):
        """ Save window attributes as settings.
        Called when window moved, resized, or closed. """
        self.settings.beginGroup("mainWindow")
        self.settings.setValue("geometry", self.saveGeometry())
        self.settings.setValue("saveState", self.saveState())
        self.settings.setValue("maximized", self.isMaximized())
        if not self.isMaximized():
            self.settings.setValue("pos", self.pos())
            self.settings.setValue("size", self.size())
        self.settings.endGroup()

    def openMenu(self, position):
        """ opens context menu. Context menu is basically a
        right-click on any cell requested. The column and row is
        parsed, and depending of which column was used to select the
        context menu contains appropriate filter offers. In case of
        clicking over datasheet it opens the datasheet in the
        browser. In case of libref it can choose the same components
        etc...
        """
        indexes = self.treeView.selectedIndexes()

        if len(indexes) < 1:
            return

        # some more validation: if datasheet clicked, we display 'open
        # datasheet' menu. But only single one is allowed at time
        if len(indexes) == 1 and\
           indexes[0].column() ==\
           self.header.get_column(self.header.DATASHEET):
            # create menu and corresponding action
            self.datasheet = self.indexData(indexes[0])
            menu = QtGui.QMenu()
            open_action = menu.addAction(
                self.tr("Open %s" % (self.datasheet, )))
            open_action.triggered.connect(self.open_datasheet)
            menu.exec_(self.treeView.viewport().mapToGlobal(position))

        # variant 2: we can select from libref, value, footprint in
        # each column _single item only_, and this one can be used to
        # create a selection mask. From obvious reasons selecting TWO
        # DIFFERENT LIBREFs e.g. does not make any sense. The same for
        # other columns. Only these three (for the moment) can be used
        # to form a filter as the others are 'user fillable', hence
        # can contain whatever information, ergo hell to make filter
        # first we have to make a 'histogram', i.e. counting
        # occurences of columns.
        d = defaultdict(int)
        # now run through all indices and do counting of columns
        for index in indexes:
            d[str(index.column())] += 1
        # now get list of values and find if each of them is exactly
        # one. First condition: look for columns which can be used for this:
        eligible_columns = all(map(lambda c: c in self.header.get_columns(
            [self.header.LIBREF,
             self.header.VALUE,
             self.header.FOOTPRINT]), map(int, d.keys())))

        # second: look if in each column there's exactly one value selected
        eligible_context = all(map(lambda c: c == 1, d.values()))
        if eligible_context and eligible_columns:
            # menu 'select same', 'disable same'
            menu = QtGui.QMenu()
            select_same = menu.addAction(self.tr("Select same"))
            select_same.triggered.connect(self.select_same_filter)
            menu.exec_(self.treeView.viewport().mapToGlobal(position))

    def select_same_filter(self):
        """ in treeview selects the rows matching the selected items filters
        """
        # we have unique columns selected, and now we need to browse
        # each row of data, check if all the conditions are satisfied,
        # and if so, then select the columns
        indexes = self.treeView.selectedIndexes()
        # get dictionary of 'column':filter_data
        d = defaultdict(int)
        for index in indexes:
            d[index.column()] = self.indexData(index)
        # and this has to be done in model as we're working over model
        # data. filter is a dictionary 'column':<filter_string>
        to_enable = self.proxy.setSelectionFilter(d)
        for idx in to_enable:
            self.treeView.selectionModel().select(
                idx,
                QtGui.QItemSelectionModel.Select)

    def open_datasheet(self):
        """ opens the browser with datasheet
        """
        # now fire the web browser with this page opened
        b = webbrowser.get('firefox')
        b.open(self.datasheet, new=0, autoraise=True)

    def open_search_browser(self, searchtext):
        """ This function calls default plugin to supply the web
        search string for a given text. This one is then used to open
        a browser window with searched item. Now, searching does not
        mean at all that the component will be found straight away. It
        just means that a page with search resuls will open, and user
        it responsible to look for a specific component further.
        """
        url = self.proxy.suppliers.search_for_component(searchtext)
        # now fire the web browser with this page opened
        b = webbrowser.get('firefox')
        b.open(url, new=0, autoraise=True)

    def tree_doubleclick(self, index):
        """ when user doubleclicks item, we search for it in farnel
        (or later whatever else) web pages. this requires a lot of
        fiddling as the component search enginer for each seller are
        different. Index is the type QModelIndex
        """
        # we process only columns libref and value as those are used
        # to search (most of the time)
        if index.column() in self.header.get_columns([self.header.LIBREF,
                                                      self.header.VALUE]):
            self.open_search_browser(self.indexData(index))


def main():
    """
    Main application body
    """

    app = QtGui.QApplication(sys.argv)
    # general settings file as follows
    QtCore.QCoreApplication.setOrganizationName("dejfson")
    QtCore.QCoreApplication.setOrganizationDomain("github.com/dejfson")
    QtCore.QCoreApplication.setApplicationName("bomizator")

    # if not given directory from the command line, ask for it
    try:
        projdir = sys.argv[1]
    except IndexError:
        projdir = str(
            QtGui.QFileDialog.getExistingDirectory(None,
                                                   app.tr("Select\
 KiCad project directory")))
    myWindow = BOMizator(projdir)
    myWindow.show()
    app.exec_()
