#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2006 David Belohrad
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA  02110-1301, USA.
#
# You can dowload a copy of the GNU General Public License here:
# http://www.gnu.org/licenses/gpl.txt
#
# Author: David Belohrad
# Email:  david.belohrad@cern.ch
#

"""
This application takes as the input the CSV bill-of-material file
generated by KiCad PCBNEW tool. It displays all the components in the
table. By clicking on read-only table items (value, manufacturer,
footprint) a default browser is launched, which searches for a
clicked keyword on the pages of farnell. This can be used to fast
search the farnell ordering codes. The application supports drag-drop
functionality, hence if user selects the farnell ordering code, it can
be dragged to the application to a specific column. This is a
hack-style tool, which allows the PCB designer to quickly search for
manufacturer part independently of the values of the libraries.
"""

import sys
import os
from PyQt4 import QtGui, uic, QtCore
from sch_parser import sch_parser
import webbrowser
from headers import headers
from collections import defaultdict
from qdropstandarditemmodel import QDropStandardItemModel
from qdesignatorsortmodel import QDesignatorSortModel

localpath = os.path.dirname(os.path.realpath(__file__))
form_class = uic.loadUiType(os.path.join(localpath, "BOMLinker.ui"))[0]


class BOMizator(QtGui.QMainWindow, form_class):
    def __init__(self, parent=None):
        """ Constructing small window
        """
        QtGui.QMainWindow.__init__(self, parent)
        self.setupUi(self)

        self.BOM = []

        # load and parse all the components from the project
        self.SCH = sch_parser(sys.argv[1])
        self.SCH.parse_components()

        self.model = QDropStandardItemModel()
        # search proxy:
        self.proxy = QDesignatorSortModel()
        self.proxy.setSourceModel(self.model)
        # assign proxy to treeView so we influence how the stuff is sorted
        self.treeView.setModel(self.proxy)
        self.treeView.setSortingEnabled(True)
        # get header object
        self.header = headers()

        sorted_header = self.header.get_headers()
        self.model.setHorizontalHeaderLabels(sorted_header)
        # set sorting of treeview by designator
        self.treeView.sortByColumn(self.header.get_column(
            self.header.DESIGNATOR), QtCore.Qt.AscendingOrder)

        # having headers we might deploy the data into the multicolumn
        # view. We need to collect all the data:
        for itemData in self.SCH.BOM():
            line = map(QtGui.QStandardItem, list(itemData))
            # some modifications to items
            # 1) designator, library part and footprint are immutable
            for i in self.header.get_columns([self.header.DESIGNATOR,
                                              self.header.LIBREF,
                                              self.header.VALUE,
                                              self.header.FOOTPRINT]):
                line[i].setEditable(False)

            self.model.appendRow(line)
        # and put the model into the place
        self.treeView.setModel(self.model)

        # as the model is filled with the data, we can resize columns
        for i in xrange(len(self.header)):
            self.treeView.resizeColumnToContents(i)

        # @TODO re-enable maximized
        # self.showMaximized()
        # connect signals to treeView so we can invoke search engines
        self.treeView.doubleClicked.connect(self.tree_doubleclick)
        # register accepting drops
        self.treeView.setAcceptDrops(True)
        self.treeView.setDropIndicatorShown(True)
        # and register custom context menu, which will be used as
        # 'filtering' to select correcly chosen indices
        self.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeView.customContextMenuRequested.connect(self.openMenu)

    def indexData(self, index):
        """ convenience function returning the data of given modelindex
        """
        return self.model.itemFromIndex(index).text()

    def openMenu(self, position):
        """ opens context menu. Context menu is basically a
        right-click on any cell requested. The column and row is
        parsed, and depending of which column was used to select the
        context menu contains appropriate filter offers. In case of
        clicking over datasheet it opens the datasheet in the
        browser. In case of libref it can choose the same components
        etc...
        """
        indexes = self.treeView.selectedIndexes()

        if len(indexes) < 1:
            return

        # some more validation: if datasheet clicked, we display 'open
        # datasheet' menu. But only single one is allowed at time
        if len(indexes) == 1 and\
           indexes[0].column() ==\
           self.header.get_column(self.header.DATASHEET):
            # create menu and corresponding action
            self.datasheet = self.indexData(indexes[0])
            menu = QtGui.QMenu()
            open_action = menu.addAction(
                self.tr("Open %s" % (self.datasheet, )))
            open_action.triggered.connect(self.open_datasheet)
            menu.exec_(self.treeView.viewport().mapToGlobal(position))

        # variant 2: we can select from libref, value, footprint in
        # each column _single item only_, and this one can be used to
        # create a selection mask. From obvious reasons selecting TWO
        # DIFFERENT LIBREFs e.g. does not make any sense. The same for
        # other columns. Only these three (for the moment) can be used
        # to form a filter as the others are 'user fillable', hence
        # can contain whatever information, ergo hell to make filter
        # first we have to make a 'histogram', i.e. counting
        # occurences of columns.
        d = defaultdict(int)
        # now run through all indices and do counting of columns
        for index in indexes:
            d[str(index.column())] += 1
        # now get list of values and find if each of them is exactly
        # one. First condition: look for columns which can be used for this:
        eligible_columns = all(map(lambda c: c in self.header.get_columns(
            [self.header.LIBREF,
             self.header.VALUE,
             self.header.FOOTPRINT]), map(int, d.keys())))

        # second: look if in each column there's exactly one value selected
        eligible_context = all(map(lambda c: c == 1, d.values()))
        if eligible_context and eligible_columns:
            # menu 'select same', 'disable same'
            menu = QtGui.QMenu()
            select_same = menu.addAction(self.tr("Select same"))
            select_same.triggered.connect(self.select_same_filter)
            menu.exec_(self.treeView.viewport().mapToGlobal(position))

    def select_same_filter(self):
        """ in treeview selects the rows matching the selected items filters
        """
        # we have unique columns selected, and now we need to browse
        # each row of data, check if all the conditions are satisfied,
        # and if so, then select the columns
        indexes = self.treeView.selectedIndexes()
        # get dictionary of 'column':filter_data
        d = defaultdict(str)
        for index in indexes:
            d[str(index.column())] = self.indexData(index)
        # and this has to be done in model as we're working over model
        # data. filter is a dictionary 'column':<filter_string>
        to_enable = self.model.setSelectionFilter(d)
        for idx in to_enable:
            self.treeView.selectionModel().select(
                idx,
                QtGui.QItemSelectionModel.Select)

    def open_datasheet(self):
        """ opens the browser with datasheet
        """
        # now fire the web browser with this page opened
        b = webbrowser.get('firefox')
        b.open(self.datasheet, new=0, autoraise=True)

    def open_search_browser(self, searchtext):
        """ This function calls default plugin to supply the web
        search string for a given text. This one is then used to open
        a browser window with searched item. Now, searching does not
        mean at all that the component will be found straight away. It
        just means that a page with search resuls will open, and user
        it responsible to look for a specific component further.
        """
        url = self.model.suppliers.search_for_component(searchtext)
        # now fire the web browser with this page opened
        b = webbrowser.get('firefox')
        b.open(url, new=0, autoraise=True)

    def tree_doubleclick(self, index):
        """ when user doubleclicks item, we search for it in farnel
        (or later whatever else) web pages. this requires a lot of
        fiddling as the component search enginer for each seller are
        different. Index is the type QModelIndex
        """
        # we process only columns libref and value as those are used
        # to search (most of the time)
        if index.column() in self.header.get_columns([self.header.LIBREF,
                                                      self.header.VALUE]):

            item = self.model.item(index.row(), index.column())
            strData = item.data(0).toPyObject()
            # this is what we're going to look after
            self.open_search_browser(str(strData))


def main():
    """
    Main application body
    """

    app = QtGui.QApplication(sys.argv)
    myWindow = BOMizator(None)
    myWindow.show()
    app.exec_()
