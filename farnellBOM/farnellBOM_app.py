#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2006 David Belohrad
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA  02110-1301, USA.
#
# You can dowload a copy of the GNU General Public License here:
# http://www.gnu.org/licenses/gpl.txt
#
# Author: David Belohrad
# Email:  david.belohrad@cern.ch
#

"""
This application takes as the input the CSV bill-of-material file
generated by KiCad PCBNEW tool. It displays all the components in the
table. By clicking on read-only table items (value, manufacturer,
footprint) a default browser is launched, which searches for a
clicked keyword on the pages of farnell. This can be used to fast
search the farnell ordering codes. The application supports drag-drop
functionality, hence if user selects the farnell ordering code, it can
be dragged to the application to a specific column. This is a
hack-style tool, which allows the PCB designer to quickly search for
manufacturer part independently of the values of the libraries.
"""

import sys
import os
from PyQt4 import QtGui, uic, QtCore
from sch_parser import sch_parser
from supplier_selector import supplier_selector
from operator import itemgetter


localpath = os.path.dirname(os.path.realpath(__file__))
form_class = uic.loadUiType(os.path.join(localpath, "BOMLinker.ui"))[0]

# things to display:
HEADER = {"Designator": 0,
          "LibRef": 1,
          "Value": 2,
          "Footprint": 3,
          "Manufacturer": 4,
          "Mfr. no": 5,
          "Datasheet": 6}


class QDropStandardItemModel(QtGui.QStandardItemModel):
    """ redefines standard item model to support drop actions
    """
    def __init__(self, parent):
        super(QDropStandardItemModel, self).__init__(parent)

    def dropMimeData(self, data, action, row, column, parent):
        """ takes care of data modifications
        """
        print "dropped into ", row, column, data.text()
        return True

    def mimeTypes(self):
        """ This class accepts only text/plain drops, hence this
        function sets up the correct mimetype
        """
        types = QtCore.QStringList()
        types.append('text/plain')
        return types

    def flags(self, index):
        """ according to which column we have cursor on, this field

        returns flags for it. Some are editable, droppable, some are
        read only
        """

        # keep default flags
        defaultFlags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled

        # if manufacturer, mfgno, datasheet, these are editable as
        # well
        if index.column() in [HEADER['Manufacturer'],
                              HEADER['Mfr. no'],
                              HEADER['Datasheet']]:
            defaultFlags |= QtCore.Qt.ItemIsEditable

        # but if we're in designator, this one can accept drops from
        # firefox/others to parse the headers and look for correct MFG
        # and others. Not all plugins can export all data
        if index.column() == HEADER['Designator']:
            defaultFlags |= QtCore.Qt.ItemIsDropEnabled

        return defaultFlags


class BOMLinker(QtGui.QMainWindow, form_class):
    def __init__(self, parent=None):
        """ Constructing small window
        """
        QtGui.QMainWindow.__init__(self, parent)
        self.setupUi(self)

        self.BOM = []

        # load and parse all the components from the project
        self.SCH = sch_parser(sys.argv[1])
        self.SCH.parse_components()

        self.model = QDropStandardItemModel(self.treeView)
        sorted_header = map(lambda c: c[0],
                            sorted(HEADER.items(),
                                   key=itemgetter(1)))
        self.model.setHorizontalHeaderLabels(sorted_header)

        # having headers we might deploy the data into the multicolumn
        # view. We need to collect all the data:
        for itemData in self.SCH.BOM():
            line = map(QtGui.QStandardItem, list(itemData))
            # some modifications to items
            # 1) designator, library part and footprint are immutable
            for i in ["Designator", "LibRef", "Value", "Footprint"]:
                line[HEADER[i]].setEditable(False)

            self.model.appendRow(line)
        # and put the model into the place
        self.treeView.setModel(self.model)

        # as the model is filled with the data, we can resize columns
        for i in xrange(len(HEADER)):
            self.treeView.resizeColumnToContents(i)

        self.showMaximized()
        # connect signals to treeView so we can invoke search engines
        self.treeView.doubleClicked.connect(self.tree_doubleclick)

        # get all sellers filters
        self.sellers = supplier_selector()

        self.treeView.setAcceptDrops(True)
        self.treeView.setDropIndicatorShown(True)

    def tree_doubleclick(self, index):
        """ when user doubleclicks item, we search for it in farnel
        (or later whatever else) web pages. this requires a lot of
        fiddling as the component search enginer for each seller are
        different. Index is the type QModelIndex
        """
        # we process only columns libref and value as those are used
        # to search (most of the time)
        if index.column() in [HEADER['LibRef'],
                              HEADER['Value']]:
            item = self.model.item(index.row(), index.column())
            strData = item.data(0).toPyObject()
            # this is what we're going to look after
            self.sellers.open_search_browser(str(strData))


def main():
    """
    Main application body
    """

    app = QtGui.QApplication(sys.argv)
    myWindow = BOMLinker(None)
    myWindow.show()
    app.exec_()
